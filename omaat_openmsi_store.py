from builtins import input


def save_arrayed_image_to_omsi_file(arrayedImage, filename=None, spotSpectra=None):
    """
    Save the data from an ArrayedImage and additional spot spectru to and OpenMSI-compliant  HDF5 file

    :param filename: Name of the output file. If filename is None, then we will ask for a filename via input
    :param arrayedImage: Instance of OMAAT ArrayedImage to be saved
    :param spotSpectra: data frame or numpy array of spot spectra generated by OMAAT

    Requires: This function requires the following packages: BASTet, h5y, numpy, pandas, pickle, datetime

    :return: Instance of omsi.dataformat.omsi_file.main_file.omsi_file of the generated output OpenMSI file
    """
    from omsi.analysis.generic import analysis_generic
    from omsi.dataformat.omsi_file.main_file import omsi_file
    import h5py
    import pickle
    import datetime
    import numpy as np
    import pandas as pd

    if filename is None:
        filename = input("Output filename: ")

    dt = datetime.datetime.now()
    curr_ana = analysis_generic(name_key="openmsi_arrayed_analysis_results_{:d}-{:d}-{:d}_{:d}h{:d}.csv".format(dt.year,dt.month,dt.day,dt.hour,dt.minute))
    dtypes = curr_ana.get_default_dtypes()
    groups = curr_ana.get_default_parameter_groups()

    curr_ana.real_analysis_type = 'omaat_lib.ArrayedImage'
    curr_ana.data_names = ['spotLocations', 'xCenters', 'yCenters', 'baseImage', 'imStack', 'spectraDF', 'arrayedImageP', 'spotSpectraP', 'spotSpectra']
    curr_ana['spotLocations'] = arrayedImage.spotLocations
    if isinstance(arrayedImage.spotList, list):
        for spot_index, spot in enumerate(arrayedImage.spotList):
            spot_name = 'spot_'+str(spot_index)
            curr_ana.data_names.append(spot_name)
            curr_ana[spot_name] = spot
    curr_ana['xCenters'] = arrayedImage.xCenters
    curr_ana['yCenters'] = arrayedImage.yCenters
    curr_ana['baseImage'] = arrayedImage.baseImage
    curr_ana['imStack'] = arrayedImage.imStack
    try:
        curr_ana['spectraDF'] = arrayedImage.spectra_df
    except AttributeError:
        curr_ana['spectraDF'] = None
    curr_ana['arrayedImageP'] = pickle.dumps(arrayedImage)
    if curr_ana['spectraDF'] is None:
        curr_ana['spectraDF'] = arrayedImage.resultsDataFrame()
    if spotSpectra is not None:
        if isinstance(spotSpectra, pd.DataFrame):
            curr_ana['spotSpectra'] = spotSpectra.as_matrix()
            curr_ana['spotSpectraP'] = pickle.dumps(spotSpectra)
        else:
            curr_ana['spotSpectra'] = np.asarray(spotSpectra)
            if curr_ana['spotSpectra'].dtype == np.dtype('O'):
                curr_ana.pop('spotSpectra')
                raise ValueError("Unsupported format for spotSpectra. Conversion to numpy resulted in type 'O'")

    curr_ana.add_parameter(name='Nrows',
                           help='Number of rows',
                           dtype=dtypes['int'],
                           required=True,
                           default=12,
                           choices=None,
                           group=groups['settings'],
                           data=arrayedImage.Nrows)
    curr_ana.add_parameter(name='Ncolumns',
                           help='Number of columns',
                           dtype=dtypes['int'],
                           required=True,
                           default=12,
                           choices=None,
                           group=groups['settings'],
                           data=arrayedImage.Ncolumns)
    curr_ana.add_parameter(name='mz',
                           help='The m/z axis of the input data',
                           dtype=dtypes['ndarray'],
                           required=True,
                           group=groups['input'],
                           data=arrayedImage.mz)
    curr_ana.add_parameter(name='ions',
                           help='List of ions used',
                           dtype=dtypes['ndarray'],
                           required=True,
                           group=groups['input'],
                           data=arrayedImage.ions)
    curr_ana.add_parameter(name='originalSize',
                           help='Original size',
                           dtype=dtypes['ndarray'],
                           required=True,
                           group=groups['input'],
                           data=arrayedImage.originalSize)
    curr_ana.add_parameter(name='filename',
                           help='The name of the input file',
                           dtype=dtypes['unicode'],
                           required=True,
                           group=groups['input'],
                           data=arrayedImage.filename)
    curr_ana.add_parameter(name='expIndex',
                           help='The index of the experiment in the input file',
                           dtype=dtypes['int'],
                           required=True,
                           group=groups['input'],
                           data=arrayedImage.expIndex)
    curr_ana.add_parameter(name='dataIndex',
                           help='The index of the dataset in the input file',
                           dtype=dtypes['int'],
                           required=True,
                           group=groups['input'],
                           data=arrayedImage.dataIndex)

    outfile = omsi_file(h5py.File(filename))
    exp = outfile.create_experiment(exp_identifier='OMAAT store')
    exp.create_analysis(curr_ana)
    outfile.flush()
    return outfile


def restore_omaat_results(filename, expIndex=0, anaIndex=0, localFile=True, openmsiSession=None):
    """
    Download the results from a previous OMAAT analysis from OpenMSI and restore them

    :param filename: Name of the input HDF5 data file
    :param expIndex: The index of the experiment with the results
    :param anaIndex: The index of the analysis with the omaat results
    :param localFile: Boolean indicating whether the filename refers to a file locally stored on
                      disk (True) or to a remote file stored on OpenMSI
    :param openmsiSession: Instance of OMAAT OpenMSISession to be used. Needed only if
                           localFile=False

    Requires: This function requires the following packages: h5y, numpy, pickle, datetime

    :return: Tuple with:
        * Instance of ArrayedImage with all results
        * Pandas dataframe with the spot spectra if available (or None)

    """
    import h5py
    import pickle
    import numpy as np
    import json

    spotSpectra = None
    arrayedImage = None
    if filename is None:
        filename = openmsiSession.filename
    if localFile:
        infile = h5py.File(filename, 'r')
        exp = infile['entry_'+str(expIndex)]
        ana = exp['analysis_'+str(anaIndex)]

        if 'spotSpectraP' in ana.keys():
            spotSpectra = pickle.loads(ana['spotSpectraP'][()])
        if 'arrayedImageP' in ana.keys():
            arrayedImage = pickle.loads(ana['arrayedImageP'][()])
    else:
        payload = {'format': 'JSON',
                   'file': filename,
                   'expIndex':expIndex,
                   'anaIndex': anaIndex,
                   'anaDataName': 'spotSpectraP'}
        url = 'https://openmsi.nersc.gov/openmsi/qcube'
        r = openmsiSession.requests_session.get(url, params=payload, stream=True)
        r.raise_for_status()
        data = np.asarray(json.loads(r.content.decode('utf-8')))
        spotSpectra = pickle.loads(data[0])

        payload['anaDataName'] = 'arrayedImageP'
        r = openmsiSession.requests_session.get(url, params=payload, stream=True)
        r.raise_for_status()
        data = np.asarray(json.loads(r.content.decode('utf-8')))
        arrayedImage = pickle.loads(data[0])

    return spotSpectra, arrayedImage


def download_file(openmsiSession, filename, saveFilename=None):
    """
    Download the indicated file from OpenMSI

    :param openmsiSession: Instance of OMAAT OpenMSISession to be used
    :param filename: The name of the file to be downloaded
    :param saveFilename: The name of the file saved on disk
    :return: Name of the file saved to disk
    """
    import os
    saveFilename = saveFilename if saveFilename is not None else os.path.basename(filename)
    payload = {'format': 'HDF5', 'file': filename}
    url = 'https://openmsi.nersc.gov/openmsi/qcube'
    r = openmsiSession.requests_session.get(url, params=payload, stream=True)
    with open(saveFilename, 'wb') as outfile:
        for chunk in r.iter_content(chunk_size=1024):
            if chunk: # filter out keep-alive new chunks
                outfile.write(chunk)
    return saveFilename


def upload_omaat_results(username=None, filename=None, session=None, machine='cori'):
    """
    Upload the given file to the OpenMSI website. The file will be generate
    using saveToOpenMSIFile if it does not exist

    :param username: The NERSC user name ot be used. A dialog will be show if set to None.
    :param filename: The name of the file to be uploaded. A dialog will be shown if set to None.
    :param username: NERSC username
    :param session: The request NERSC session with NEWT
    :param machine: The machine at NERSC to which the file should be uploaded. (default='cori')


    Requires: This function requires the following packages: BASTet, os

    :return: Tuple with the:
            * boolean indicating whether the file upload was successful,
            * boolean indicating whether the setting of file permissions was successful
            * boolean indicating whether the registration with OpenMSI was successful
            * the NEWT session (or None if persist_session is False)
    """
    from omsi.shared.omsi_web_helper import WebHelper
    from omsi.dataformat.omsi_file.main_file import omsi_file
    import getpass
    import os

    # Determine the filename
    if filename is None:
        filename = input("Output filename: ")
    # Determine the username
    if username is None:
        uname = input("NERSC username: ")
        username = uname

    # Check that the file is valid
    if not omsi_file.is_valid_dataset(filename):
        if os.path.exists(filename):
            raise ValueError("The file is not a valid OpenMSI file")
        else:
            raise ValueError("The file does not seem to exsit.")

    # Upload the file to nersc and register it with OpenMSIs
    try:
        upload_successful, permissions_successfull, register_successful, temps = \
            WebHelper.upload_file_to_nersc(filepath=filename,
                                           username=username,
                                           register=True,
                                           session=session,
                                           persist_session=(session is not None),
                                           machine=machine)
        try:
            import IPython.display
            IPython.display.clear_output()
        except:
            pass
    except ValueError as e:
        if e.message == "Authentication failed.":
            print("Authentication failed. Please try again.")
            return {}
        else:
            raise
    return upload_successful, permissions_successfull, register_successful, temps

